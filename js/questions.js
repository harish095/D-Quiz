/*All questions in the quiz goes here in the data object.....*/
var data =
[
	[
		{
			"question"	: "Stack in data structure is _________ ",
			"option1"	: "FIFO",
			"option2"	: "LILO",
			"option3"	: "LIFO",
			"option4"	: "None of these",
			"answer"	: 3
		},
		{
			"question"	: "In stack inserting an element is called _______",
			"option1"	: "pop",
			"option2"	: "push",
			"option3"	: "create",
			"option4"	: "evaluation",
			"answer"	: 2
		},
		{
			"question"	: "In Stack deleting an element is called __________",
			"option1"	: "push",
			"option2"	: "delete",
			"option3"	: "remove",
			"option4"	: "pop",
			"answer"	: 4
		},
		{
			"question"	: "In stack if user tries to remove an element from empty stack . It is ________",
			"option1"	: "Empty collection",
			"option2"	: "Garbage collection",
			"option3"	: "Overflow of stack",
			"option4"	: "Underflow of stack",
			"answer"	: 4
		},
		{
			"question"	: "If user pushes an element in stack which is full then stack becomes ________",
			"option1"	: "underflow",
			"option2"	: "overflow",
			"option3"	: "userflow",
			"option4"	: "crash",
			"answer"	: 2
		},
		{
			"question"	: "In order to keep track of current top most element we need to maintain a variable",
			"option1"	: "True",
			"option2"	: "False",
			"option3"	: "Not Necessarily",
			"option4"	: "User choice",
			"answer"	: 1
		},
		{
			"question"	: "The variable denoting topmost element of stack is ____",
			"option1"	: "first",
			"option2"	: "Top",
			"option3"	: "stack",
			"option4"	: "data",
			"answer"	: 2
		},
		{
			"question"	: "The Top is initialized as _________",
			"option1"	: "-1",
			"option2"	: "1",
			"option3"	: "3",
			"option4"	: "0",
			"answer"	: 1
		},
		{
			"question"	: "Stack is a _________",
			"option1"	: "Linear data structure",
			"option2"	: "Non-Linear Data structure",
			"option3"	: "Multiple Data structure",
			"option4"	: "None",
			"answer"	: 1
		},
		{
			"question"	: "Stack is also called as _______",
			"option1"	: "Non-Restricted DS",
			"option2"	: "Restricted DS",
			"option3"	: "Anti-Restricted",
			"option4"	: "None",
			"answer"	: 2
		},
		{
			"question"	: "If a stack encounters an overflow on inserting 5 elements what is its size",
			"option1"	: "5",
			"option2"	: "4",
			"option3"	: "6",
			"option4"	: "1",
			"answer"	: 2
		},
		{
			"question"	: "Stack uses ________ implementation",
			"option1"	: "Array",
			"option2"	: "List",
			"option3"	: "variable",
			"option4"	: "none",
			"answer"	: 1
		},
		{
			"question"	: "The postfix expression for *+ab-cd is?",
			"option1"	: "ab+cd-*",
			"option2"	: "abcd+-*",
			"option3"	: "ab+cd*-",
			"option4"	: "ab+-cd*",
			"answer"	: 1
		},
		{
			"question"	: "If the sequence of operations - push(1), push(2), pop, push(1), push(2), pop, pop, pop, push(2), pop are performed. Sequence of popped out values are:",
			"option1"	: "2,2,1,2,2",
			"option2"	: "2,1,2,2,1",
			"option3"	: "2,1,2,2,2",
			"option4"	: "2,2,1,1,2",
			"answer"	: 4
		},
		{
			"question"	: "Which of the Following does not relate to stacks?",
			"option1"	: "LIFO list",
			"option2"	: "Piles",
			"option3"	: "FIFO list",
			"option4"	: "Push-down lists",
			"answer"	: 3
		},
		{
			"question"	: "Which of the following are the applications of stack?",
			"option1"	: "Towers of Hanoi",
			"option2"	: "Infix to postfix",
			"option3"	: "Infix to prefix",
			"option4"	: "All of the above",
			"answer"	: 4
		},
		{
			"question"	: "In Linked list implementation of stack Top is initialized to",
			"option1"	: "1",
			"option2"	: "2",
			"option3"	: "NULL",
			"option4"	: "0",
			"answer"	: 3
		},
		{
			"question"	: "In push operation we do:",
			"option1"	: "Top++",
			"option2"	: "Top--",
			"option3"	: "Top=0",
			"option4"	: "None",
			"answer"	: 1
		},
		{
			"question"	: "In pop operation we do:",
			"option1"	: "top++",
			"option2"	: "top=0",
			"option3"	: "top--",
			"option4"	: "None",
			"answer"	: 3
		},
		{
			"question"	: "If top==-1 it means that stack is",
			"option1"	: "Empty",
			"option2"	: "Full",
			"option3"	: "Filled",
			"option4"	: "Overflow",
			"answer"	: 1
		},
		{
			"question"	: "If top == array size it means the stack is:",
			"option1"	: "Under flow",
			"option2"	: "Full",
			"option3"	: "Empty",
			"option4"	: "None",
			"answer"	: 2
		},
		{
			"question"	: "In a stack containing 1 18 34 65 22 what element will you get after popping three times",
			"option1"	: "18",
			"option2"	: "65",
			"option3"	: "34",
			"option4"	: "1",
			"answer"	: 3
		},
		{
			"question"	: "In a stack Top=",
			"option1"	: "First element",
			"option2"	: "Last element",
			"option3"	: "Middle element",
			"option4"	: "Second element",
			"answer"	: 2
		},
		{
			"question"	: "Stack is an _________",
			"option1"	: "BBT",
			"option2"	: "COD",
			"option3"	: "BCE",
			"option4"	: "ADT",
			"answer"	: 4
		},
		{
			"question"	: "Stack was first proposed in",
			"option1"	: "1957",
			"option2"	: "1980",
			"option3"	: "1946",
			"option4"	: "1943",
			"answer"	: 3
		},
		{
			"question"	: "Top of the stack is called ",
			"option1"	: "Seek",
			"option2"	: "Meek",
			"option3"	: "Geek",
			"option4"	: "Peek",
			"answer"	: 4
		},
		{
			"question"	: "The Array which is Most efficient implementation of stack is",
			"option1"	: "Static",
			"option2"	: "Dynamic",
			"option3"	: "Normal",
			"option4"	: "None",
			"answer"	: 2
		},
		{
			"question"	: "The Language which donot call for stack implemention ",
			"option1"	: "Perl",
			"option2"	: "LISP",
			"option3"	: "Python",
			"option4"	: "ALL",
			"answer"	: 4
		},
		{
			"question"	: "The Process in which n topmost items are moved on stack in rotating fashion is called",
			"option1"	: "Roll",
			"option2"	: "None",
			"option3"	: "Move n",
			"option4"	: "Topmove n",
			"answer"	: 1
		},
		{
			"question"	: "The process in which two topmost elements on stack Exchange places is called",
			"option1"	: "Exchange",
			"option2"	: "change top",
			"option3"	: "Swap",
			"option4"	: "Both A and C",
			"answer"	: 4
		},
		{
			"question"	: "The processor which has special addressing modes for stack implementation is:",
			"option1"	: "X86",
			"option2"	: "PDP-11",
			"option3"	: "Z80",
			"option4"	: "6502",
			"answer"	: 2
		},
		{
			"question"	: "Processor which has special instructions to implement stack pointers is",
			"option1"	: "6502",
			"option2"	: "Z80",
			"option3"	: "X86",
			"option4"	: "All",
			"answer"	: 4
		},
		{
			"question"	: "Virtual Machines which are stack oriented are:",
			"option1"	: "P-Code machine",
			"option2"	: "Java Virtual machine ",
			"option3"	: "None",
			"option4"	: "Both A and B",
			"answer"	: 4
		},
		{
			"question"	: "The Applications of stack are:1)Expression Evaluation 2)Syntax parsing 3)Back Tracking 4)Gaming",
			"option1"	: "1&2",
			"option2"	: "2&4",
			"option3"	: "1,2&3",
			"option4"	: "All",
			"answer"	: 3
		},
		{
			"question"	: "Stack can be implemented using",
			"option1"	: "C++",
			"option2"	: "Perl",
			"option3"	: "C",
			"option4"	: "Both A and C",
			"answer"	: 4
		},
		{
			"question"	: "Stacks may be Implemented to have a _______ capacity",
			"option1"	: "Bounded",
			"option2"	: "Unbounded",
			"option3"	: "Multi-Bounded",
			"option4"	: "Uni-Bounded",
			"answer"	: 1
		},
		{
			"question"	: "The Elements Residing Longest in the stack are:",
			"option1"	: "higher",
			"option2"	: "lower",
			"option3"	: "middle",
			"option4"	: "just above middle",
			"answer"	: 2
		},
		{
			"question"	: "Stacks was proposed by",
			"option1"	: "Mark D.Henry",
			"option2"	: "Adam Wilkins",
			"option3"	: "Alan T.Turning",
			"option4"	: "Dennis Richie",
			"answer"	: 3
		},
		{
			"question"	: "In a stack containing 1 2 3 4 5 and array size 5 ,if we do pop, pop, push(6), push(7), push(8) we will get:",
			"option1"	: "1 2 3 6 7",
			"option2"	: "1 2 3 6 7 8",
			"option3"	: "1 2 6 7 8",
			"option4"	: "overflow",
			"answer"	: 4
		},
		{
			"question"	: "In a stack if You do: push(1), push(2), push(3), pop, pop You will have:",
			"option1"	: "1",
			"option2"	: "2",
			"option3"	: "3",
			"option4"	: "underflow",
			"answer"	: 1
		},
		{
			"question"	: "Stack is used in graphs in",
			"option1"	: "BFS",
			"option2"	: "DFS",
			"option3"	: "Both A and B",
			"option4"	: "None",
			"answer"	: 2
		},
		{
			"question"	: "Operations on Stack are:",
			"option1"	: "Push",
			"option2"	: "Pop",
			"option3"	: "New",
			"option4"	: "Both A and B",
			"answer"	: 4
		},
		{
			"question"	: "The Value of postfix expression 123*+4- is",
			"option1"	: "3",
			"option2"	: "5",
			"option3"	: "6",
			"option4"	: "7",
			"answer"	: 1
		},
		{
			"question"	: "The Value of postfix expression 27*8- is",
			"option1"	: "8",
			"option2"	: "3",
			"option3"	: "6",
			"option4"	: "9",
			"answer"	: 3
		},
		{
			"question"	: "The Value of postfix expression 93/4+ is",
			"option1"	: "3",
			"option2"	: "7",
			"option3"	: "0",
			"option4"	: "2",
			"answer"	: 2
		},
		{
			"question"	: "In push opration array[top]=val occurs _______ top++",
			"option1"	: "before",
			"option2"	: "after",
			"option3"	: "same step",
			"option4"	: "There is no such step",
			"answer"	: 2
		},
		{
			"question"	: "Components required in stack :",
			"option1"	: "Array size",
			"option2"	: "Top",
			"option3"	: "Value",
			"option4"	: "All",
			"answer"	: 4
		},
		{
			"question"	: "Stack concept was independently developed by",
			"option1"	: "Klaus Samuels",
			"option2"	: "Richard Holding",
			"option3"	: "Charles Leonard Hamblin",
			"option4"	: "Tom Rilee",
			"answer"	: 3
		},
		{
			"question"	: "In sytem Security, Malicious parties may attempt a ____ attack which takes advantage of stack implementations",
			"option1"	: "Stack cracking",
			"option2"	: "Stack breaking",
			"option3"	: "Stack smashing",
			"option4"	: "Stack hacking",
			"answer"	: 3
		},
		{
			"question"	: "Stack applications in Real life :",
			"option1"	: "Books in Library",
			"option2"	: "Blank sheets of paper in printer tray",
			"option3"	: "None",
			"option4"	: "Both A and B",
			"answer"	: 4
		}
	],
	[
		{
			"question"	: "Queue is __________ ",
			"option1"	: "ADT ",
			"option2"	: "ABT",
			"option3"	: "CUT",
			"option4"	: "BBT",
			"answer"	: 1
		},
		{
			"question"	: "Queue implements _________",
			"option1"	: "LIFO",
			"option2"	: "FILO",
			"option3"	: "LILA",
			"option4"	: "FIFO",
			"answer"	: 4
		},
		{
			"question"	: "Queue is a _________ data structure",
			"option1"	: "Non-Linear",
			"option2"	: "Linear",
			"option3"	: "Multi-Linear",
			"option4"	: "None",
			"answer"	: 2
		},
		{
			"question"	: "Queue uses _______ Implementation",
			"option1"	: "Array",
			"option2"	: "Single Variable",
			"option3"	: "Multi-Variable",
			"option4"	: "No variable",
			"answer"	: 1
		},
		{
			"question"	: "Inserting an Element in Queue is ______",
			"option1"	: "Dequeue",
			"option2"	: "Enqueue",
			"option3"	: "Delete",
			"option4"	: "Create",
			"answer"	: 2
		},
		{
			"question"	: "Deleting an Element in Queue is _________",
			"option1"	: "Enqueue",
			"option2"	: "Delete",
			"option3"	: "Dequeue",
			"option4"	: "Remove",
			"answer"	: 3
		},
		{
			"question"	: "The Pointer implementation of queue uses ",
			"option1"	: "Array",
			"option2"	: "Linked list",
			"option3"	: "Single variable",
			"option4"	: "Loop",
			"answer"	: 2
		},
		{
			"question"	: "Element Residing Longest in the Queue is",
			"option1"	: "First",
			"option2"	: "Middle",
			"option3"	: "Last",
			"option4"	: "Last Before",
			"answer"	: 3
		},
		{
			"question"	: "The Variable used to Denote Starting/Forward End is",
			"option1"	: "Rear",
			"option2"	: "Start",
			"option3"	: "Begin",
			"option4"	: "Front",
			"answer"	: 4
		},
		{
			"question"	: "The Variable used to Denote Last/backward End is",
			"option1"	: "Last",
			"option2"	: "Back",
			"option3"	: "Rear",
			"option4"	: "Front",
			"answer"	: 3
		},
		{
			"question"	: "In Array Implementation of Queue Front is initialized to",
			"option1"	: "-1",
			"option2"	: "2",
			"option3"	: "1",
			"option4"	: "0",
			"answer"	: 1
		},
		{
			"question"	: "In Array Implementation of Queue Front is Initialized to",
			"option1"	: "1",
			"option2"	: "-1",
			"option3"	: "0",
			"option4"	: "2",
			"answer"	: 2
		},
		{
			"question"	: "In Array Implementation of Queue Rear is Initialized to",
			"option1"	: "-1",
			"option2"	: "0",
			"option3"	: "1",
			"option4"	: "2",
			"answer"	: 1
		},
		{
			"question"	: "In Pointer Implementation of Queue Front is Initialized to",
			"option1"	: "0",
			"option2"	: "1",
			"option3"	: "NULL",
			"option4"	: "-1",
			"answer"	: 3
		},
		{
			"question"	: "In Pointer Implementation of Queue Rear is Initialized to ",
			"option1"	: "NULL",
			"option2"	: "1",
			"option3"	: "-1",
			"option4"	: "0",
			"answer"	: 1
		},
		{
			"question"	: "If Front==-1 and Rear==-1 it means that the queue is",
			"option1"	: "Full",
			"option2"	: "Semi-Full",
			"option3"	: "Empty",
			"option4"	: "It has -1 at front and rear end",
			"answer"	: 3
		},
		{
			"question"	: "if Rear == arraysize-1 then it means queue is",
			"option1"	: "Empty",
			"option2"	: "Full",
			"option3"	: "No Element Exixts",
			"option4"	: "Both A and C",
			"answer"	: 2
		},
		{
			"question"	: "In Enqueue operation Element is Inserted in ______ end",
			"option1"	: "Front",
			"option2"	: "Rear",
			"option3"	: "Middle",
			"option4"	: "Both A and B",
			"answer"	: 2
		},
		{
			"question"	: "In Dequeue operation Element is Removed from ______ end",
			"option1"	: "Rear",
			"option2"	: "Front",
			"option3"	: "Middle",
			"option4"	: "Both B and C",
			"answer"	: 2
		},
		{
			"question"	: "In Enqueue operation ________ is done",
			"option1"	: "Rear--",
			"option2"	: "Rear++",
			"option3"	: "Front++",
			"option4"	: "Front--",
			"answer"	: 2
		},
		{
			"question"	: "In Dequeue Operation ________ is done",
			"option1"	: "Front--",
			"option2"	: "Rear--",
			"option3"	: "Front++",
			"option4"	: "Rear++",
			"answer"	: 3
		},
		{
			"question"	: "Array Implementation of Queue requires",
			"option1"	: "Front",
			"option2"	: "Rear",
			"option3"	: "Array size",
			"option4"	: "ALL",
			"answer"	: 4
		},
		{
			"question"	: "The Problem of Deletion in Linear Queue is overcome by using",
			"option1"	: "Multiple Queue",
			"option2"	: "Circular Queue",
			"option3"	: "Square Queue",
			"option4"	: "Basic Queue",
			"answer"	: 1
		},
		{
			"question"	: "Identify the data structure which allows deletions at both ends of the list but insertion at only one end.",
			"option1"	: "Input-restricted deque",
			"option2"	: "Output-restricted deque",
			"option3"	: "Priority queues",
			"option4"	: "None of above",
			"answer"	: 1
		},
		{
			"question"	: "Which data structure allows deleting data elements from front and inserting at rear?",
			"option1"	: "Stacks ",
			"option2"	: "Queues",
			"option3"	: "Deques",
			"option4"	: "Binary search tree",
			"answer"	: 2
		},
		{
			"question"	: "Queues provide services in ",
			"option1"	: "Science",
			"option2"	: "Transport",
			"option3"	: "computer science",
			"option4"	: "All",
			"answer"	: 4
		},
		{
			"question"	: "Queues perform ________ function",
			"option1"	: "stream",
			"option2"	: "transfer",
			"option3"	: "buffer",
			"option4"	: "join",
			"answer"	: 3
		},
		{
			"question"	: "Common implementations of queue are",
			"option1"	: "Linked lists",
			"option2"	: "Circular buffer",
			"option3"	: "Both A and B",
			"option4"	: "None",
			"answer"	: 3
		},
		{
			"question"	: "A queue limited to fixed number of items is:",
			"option1"	: "Bounded queue",
			"option2"	: "Fixed queue",
			"option3"	: "Tangled queue",
			"option4"	: "Flexible queue",
			"answer"	: 1
		},
		{
			"question"	: "Deque in queues means",
			"option1"	: "Direct queue",
			"option2"	: "Diagonal queue",
			"option3"	: "Double-ended queue",
			"option4"	: "Double queue",
			"answer"	: 3
		},
		{
			"question"	: "Priority queue is ____________",
			"option1"	: "ADT",
			"option2"	: "CDT",
			"option3"	: "BGT",
			"option4"	: "APT",
			"answer"	: 1
		},
		{
			"question"	: "Priority Queues are implemented in",
			"option1"	: "Loop",
			"option2"	: "Conditionals",
			"option3"	: "Stacks",
			"option4"	: "Heaps",
			"answer"	: 4
		},
		{
			"question"	: "Priority queues add elements into queues with added ",
			"option1"	: "Priority",
			"option2"	: "Address",
			"option3"	: "Location",
			"option4"	: "Value",
			"answer"	: 1
		},
		{
			"question"	: "LANs use ______________ technique",
			"option1"	: "Queuing",
			"option2"	: "Priority queuing",
			"option3"	: "Setting",
			"option4"	: "Enqueuing",
			"answer"	: 2
		},
		{
			"question"	: "Priority queuing can manage ",
			"option1"	: "Bandwith",
			"option2"	: "Wavelength",
			"option3"	: "Colour",
			"option4"	: "Background",
			"answer"	: 1
		},
		{
			"question"	: "Queues are in used in graphs in",
			"option1"	: "DFS",
			"option2"	: "Both A and C",
			"option3"	: "BFS",
			"option4"	: "None",
			"answer"	: 3
		},
		{
			"question"	: "The Applications of priority queues are",
			"option1"	: "Factorial computation",
			"option2"	: "Multi-tasking",
			"option3"	: "ROAM triangulation Algorithm",
			"option4"	: "Towers of Hanoi",
			"answer"	: 3
		},
		{
			"question"	: "Batch queue is also called as ",
			"option1"	: "Marked queue",
			"option2"	: "Piled queue",
			"option3"	: "Job queue",
			"option4"	: "Group queue",
			"answer"	: 3
		},
		{
			"question"	: "Queue used for enabling delay in command execution is",
			"option1"	: "Delay queue",
			"option2"	: "Enable queue",
			"option3"	: "Command queue",
			"option4"	: "None",
			"answer"	: 3
		},
		{
			"question"	: "Which of the following shows the difference between a queue and a stack?",
			"option1"	: "Queues require linked lists, but stacks do not",
			"option2"	: "Stacks require linked lists, but queues do not",
			"option3"	: "Queue is used for complex programs and stack for simple programs",
			"option4"	: "Queues use two ends of the structure; stacks use only one",
			"answer"	: 4
		},
		{
			"question"	: "The initial configuration of the queue is having the elements ‘x, y, z, a’ forming a queue. To get the new configuration ‘a, z, y, x’ one needs a minimum of",
			"option1"	: "3 additions and 4 deletion",
			"option2"	: "3 deletions and 4 additions",
			"option3"	: "3 deletions and 2 additions",
			"option4"	: "3 deletions and 3 additions",
			"answer"	: 4
		},
		{
			"question"	: "The initial configuration of the queue is having the elements ‘x, y, z, a’ forming a queue. To form the new configuration in the above problem, what best data structure is seems to be used?",
			"option1"	: "Tree",
			"option2"	: "Queue",
			"option3"	: "Linked List",
			"option4"	: "Circular Queue",
			"answer"	: 2
		},
		{
			"question"	: "If f, r are the front, rear pointers respectively in a circular queue then the condition (( f – r + size) % size == 1) && ( (f != 0) || (r != -1) ) represents",
			"option1"	: "Queue has only one element",
			"option2"	: "Two Elements",
			"option3"	: "More than 2 elements but not full",
			"option4"	: "Queue is full",
			"answer"	: 4
		},
		{
			"question"	: "To implement the Round Robin algorithm, which of the following data structure is used?",
			"option1"	: "Stack",
			"option2"	: "Linear Queue",
			"option3"	: "Circular Queue",
			"option4"	: "Priority Queue ",
			"answer"	: 3
		},
		{
			"question"	: "In a circular queue, we can disambiguate empty from full queue by",
			"option1"	: "Using a gap in the array",
			"option2"	: "Incrementing queue positions by 2 instead of 1",
			"option3"	: "Keeping a count of the number of elements",
			"option4"	: "(a) and (c) above",
			"answer"	: 4
		},
		{
			"question"	: "Provided the space is available, then to insert an element in the queue, we can use for the following structure struct queue { int Q[20]; int f, r; }Q;",
			"option1"	: "++Q.Q[Q.r] = x;",
			"option2"	: "Q.Q[++Q.r] = x",
			"option3"	: "Q.Q[Q.r]++ = x;",
			"option4"	: "Syntax error",
			"answer"	: 2
		},
		{
			"question"	: "If the characters 'D', 'C', 'B', 'A' are placed in a queue (in that order), and then removed one at a time, in what order will they be removed?",
			"option1"	: "DCBA",
			"option2"	: "ABDC",
			"option3"	: "DCAB",
			"option4"	: "ABCD",
			"answer"	: 1
		},
		{
			"question"	: "I have implemented the queue with a linked list, keeping track of a front node and a rear node with two reference variables. Which of these reference variables will change during an insertion into a NONEMPTY queue?",
			"option1"	: "Neither changes",
			"option2"	: "Only front changes",
			"option3"	: "Only rear changes",
			"option4"	: "Both change",
			"answer"	: 3
		},
		{
			"question"	: "Minimum number of queue(s) needed to implement the priority queue is",
			"option1"	: "Two",
			"option2"	: "One",
			"option3"	: "Three",
			"option4"	: "Depends upon the application",
			"answer"	: 1
		},
		{
			"question"	: "With the “wrap around” implementation of a queue, which of the following code should be used to work out the next location of deletion?",
			"option1"	: "front++",
			"option2"	: "front--",
			"option3"	: "front = (front % max_queue_size) + 1",
			"option4"	: "front = (front ++) % max_queue_size",
			"answer"	: 4
		},
		{
			"question"	: "If for a given ‘Queue’ initially f=0 and r=-1, then f = r refers to",
			"option1"	: "Queue is empty",
			"option2"	: "Queue is full",
			"option3"	: "Queue has two elements",
			"option4"	: "Exactly one element is there",
			"answer"	: 4
		}
	],
	[
		{
			"question"	: "Suppose cursor refers to a node in a linked list, what statement changes cursor so that it refers to the next node? ",
			"option1"	: "cursor++;",
			"option2"	: "cursor = link;",
			"option3"	: "cursor += link;",
			"option4"	: "cursor = cursor->link;",
			"answer"	: 4
		},
		{
			"question"	: "Consider the following two statements and choose the correct option:   I.According to Access strategies Linked List is a linear one.   II.According to Storage Linked List is a Non-linear one.",
			"option1"	: "(I) is true but (II) is false",
			"option2"	: "(I) is false but (II) is true",
			"option3"	: "Both (I) and (II) are true",
			"option4"	: "Both (I) and (II) are false",
			"answer"	: 3
		},
		{
			"question"	: "Which of the following pairs of statements are identical?",
			"option1"	: "(*ptr).element AND ptr.element",
			"option2"	: "*ptr.element AND ptr.element",
			"option3"	: "*ptr.element AND ptr.element",
			"option4"	: "(*ptr).element AND ptr.element.",
			"answer"	: 4
		},
		{
			"question"	: "A linked list always contains elements that can be described as",
			"option1"	: "Redundant",
			"option2"	: "Recursive",
			"option3"	: "Self-referential",
			"option4"	: "Bidirection",
			"answer"	: 3
		},
		{
			"question"	: "Tree construction, which is the suitable and efficient data structure?",
			"option1"	: "Array",
			"option2"	: "Linked list",
			"option3"	: "Stack",
			"option4"	: "Queue",
			"answer"	: 2
		},
		{
			"question"	: "When we organize our data as an ordered list, what is the time complexity of inserting/deleting a data item to/from the list?",
			"option1"	: "O(length_of_list*length_of_list)",
			"option2"	: "O(length_of_list)",
			"option3"	: "O(log(length_of_list * length_of_list))",
			"option4"	: "O(1)",
			"answer"	: 2
		},
		{
			"question"	: "How many fields are required by a node to represent the polynomials in computer memory using linked list?",
			"option1"	: "Two fields",
			"option2"	: "Four fields",
			"option3"	: "More than three fields",
			"option4"	: "Three fields",
			"answer"	: 4
		},
		{
			"question"	: "The direct or random access of element is not possible in",
			"option1"	: "Array",
			"option2"	: "String",
			"option3"	: "Linked List",
			"option4"	: "Both (a) and (b) above",
			"answer"	: 3
		},
		{
			"question"	: "In linked list, a node contains atleast",
			"option1"	: "Node address field, data field",
			"option2"	: "Node number, data field",
			"option3"	: "Next address field, information field",
			"option4"	: "Node number, information field",
			"answer"	: 3
		},
		{
			"question"	: "In the linked list implementation of the queue, where does the insert method place the new entry on the linked list?",
			"option1"	: "At the head",
			"option2"	: "At the tail",
			"option3"	: "After all other entries that are greater than the new entry",
			"option4"	: "After all other entries that are smaller than the new entry",
			"answer"	: 2
		},
		{
			"question"	: "Suppose cursor refers to a node in a linked list. What boolean expression will be true when cursor refers to the tail node of ",
			"option1"	: "cursor.next == null",
			"option2"	: "cursor == null",
			"option3"	: "cursor.data == null",
			"option4"	: "cursor.data == 0",
			"answer"	: 1
		},
		{
			"question"	: "Four statements about lists and stacks are below.Three of them are correct. Which one is incorrect?",
			"option1"	: "Lists can be implemented by using arrays or linked lists",
			"option2"	: "Lists are the dynamic data structures",
			"option3"	: "A stack is a special kind of list in which all insertions and deletions take place at one end",
			"option4"	: "A list is a sequence of one or more data items",
			"answer"	: 4
		},
		{
			"question"	: "Which boolean expression indicates whether the number in two nodes (p and q) are the same? Assume that neither p nor q is null.",
			"option1"	: "p == q",
			"option2"	: "p.data == q.data",
			"option3"	: "p.link == q.link",
			"option4"	: "p.link = q.link",
			"answer"	: 2
		},
		{
			"question"	: "The linked list which can be processed in either of the Direction is",
			"option1"	: "Single linked list",
			"option2"	: "Circular linked list",
			"option3"	: "Stack implemented as linked list",
			"option4"	: "Double linked list",
			"answer"	: 4
		},
		{
			"question"	: "Searching the linked list requires linked list be created in ",
			"option1"	: "Ascending order",
			"option2"	: "Descending order",
			"option3"	: "Under flow condition",
			"option4"	: "Any order",
			"answer"	: 4
		},
		{
			"question"	: "What kind of list is best to answer questions such as What is the item at position n?",
			"option1"	: "Lists implemented with an array",
			"option2"	: "Doubly-linked lists",
			"option3"	: "Singly-linked lists",
			"option4"	: "Doubly-linked or singly-linked lists are equally best",
			"answer"	: 1
		},
		{
			"question"	: "A technique which collects all deleted spaces onto free storage list is called",
			"option1"	: "Static memory allocation",
			"option2"	: "Garbage collection",
			"option3"	: "Calloc",
			"option4"	: "Dynamic memory allocation",
			"answer"	: 2
		},
		{
			"question"	: "Null pointer is used to define I. End of linked list. II.    Empty pointer field of a structure. III.   The linked list is empty",
			"option1"	: "Only (I) above",
			"option2"	: "Only (II) above",
			"option3"	: "Only (III) above",
			"option4"	: "All (I), (II) and (III) above.",
			"answer"	: 4
		},
		{
			"question"	: "The statement head->Link->Link->Link = NULL terminates a linked list after its __________ node",
			"option1"	: "2nd",
			"option2"	: "4th",
			"option3"	: "5th",
			"option4"	: "3rd",
			"answer"	: 4
		},
		{
			"question"	: "Which of the following statements is/are TRUE?  i) ADTs define how data is stored and manipulated.   ii) Every linked list has to have at least one external pointer.  iii) Recursive solutions may be easier to understand.",
			"option1"	: "(i),(ii) and (iii) above",
			"option2"	: "Only (i) above",
			"option3"	: "Only (ii) above",
			"option4"	: "Only (iii)above",
			"answer"	: 3
		},
		{
			"question"	: "Having the address of the node to be deleted in doubly linked list, the node can be deleted",
			"option1"	: "Without traversing the list",
			"option2"	: "Only after traversing the list from the head",
			"option3"	: "Only after traversing the list from the tail",
			"option4"	: "(b) or (c) above ",
			"answer"	: 1
		},
		{
			"question"	: "In Linked list Head or start pointer is initialized to",
			"option1"	: "0",
			"option2"	: "1",
			"option3"	: "NULL",
			"option4"	: "-1",
			"answer"	: 3
		},
		{
			"question"	: "To Forward Traverse a node __________ is used",
			"option1"	: "q=next",
			"option2"	: "q=q->next",
			"option3"	: "q=q->prev",
			"option4"	: "q=q->NULL",
			"answer"	: 2
		},
		{
			"question"	: "The next of next node of t is denoted by",
			"option1"	: "t->next",
			"option2"	: "next->t",
			"option3"	: "t->next->next",
			"option4"	: "next->t->next",
			"answer"	: 3
		},
		{
			"question"	: "Linked List is used in",
			"option1"	: "Stacks",
			"option2"	: "Trees",
			"option3"	: "Queues",
			"option4"	: "All",
			"answer"	: 4
		},
		{
			"question"	: "In C++ Keyword used to create a node is",
			"option1"	: "malloc",
			"option2"	: "new",
			"option3"	: "create",
			"option4"	: "make",
			"answer"	: 2
		},
		{
			"question"	: "In C keyword used to create a node is",
			"option1"	: "malloc",
			"option2"	: "new",
			"option3"	: "create",
			"option4"	: "make",
			"answer"	: 1
		},
		{
			"question"	: "Linked lists use __________ operator",
			"option1"	: "->",
			"option2"	: "::",
			"option3"	: "()",
			"option4"	: "[]",
			"answer"	: 1
		},
		{
			"question"	: "To insert 35 at head of the list we do",
			"option1"	: "Insert(35)",
			"option2"	: "push(35)",
			"option3"	: "head->val=35",
			"option4"	: "enqueue(35)",
			"answer"	: 3
		},
		{
			"question"	: "To copy string from n1 to temp->name we use",
			"option1"	: "strcat",
			"option2"	: "strrev",
			"option3"	: "strncat",
			"option4"	: "strcpy",
			"answer"	: 4
		},
		{
			"question"	: "In a Double-Linked list the pointers used are",
			"option1"	: "*next",
			"option2"	: "Both A and C",
			"option3"	: "*prev",
			"option4"	: "None",
			"answer"	: 2
		},
		{
			"question"	: "Linked list is ___________ Data structure",
			"option1"	: "Static",
			"option2"	: "Boundless",
			"option3"	: "Dynamic",
			"option4"	: "Variable",
			"answer"	: 3
		},
		{
			"question"	: "Linked lists have_____________ access",
			"option1"	: "Random",
			"option2"	: "Multiple",
			"option3"	: "Parallel",
			"option4"	: "Sequential",
			"answer"	: 4
		},
		{
			"question"	: "If the last node is linked to the first node of the list it is called _________ linked list",
			"option1"	: "Triangular",
			"option2"	: "Circular",
			"option3"	: "Square",
			"option4"	: "Rectangular",
			"answer"	: 2
		},
		{
			"question"	: "The link fields need not be physically part of the nodes.This type of linking is ",
			"option1"	: "Direct linking",
			"option2"	: "In-direct linking",
			"option3"	: "Chain linking",
			"option4"	: "Hash linking",
			"answer"	: 4
		},
		{
			"question"	: "Linear singly linked lists also allow _______________",
			"option1"	: "Tail-sharing",
			"option2"	: "Head-sharing",
			"option3"	: "Node-sharing",
			"option4"	: "Link-sharing",
			"answer"	: 1
		},
		{
			"question"	: "Double-linked lists require more space per node unless one uses ______",
			"option1"	: "NOT-linking",
			"option2"	: "AND-linking",
			"option3"	: "XOR-linking",
			"option4"	: "OR-linking",
			"answer"	: 1
		},
		{
			"question"	: "Languages which have single –linked list built in is",
			"option1"	: "Lisp",
			"option2"	: "Scheme",
			"option3"	: "Both A and B",
			"option4"	: "Fortran",
			"answer"	: 3
		},
		{
			"question"	: "A _________ is a linked list in which each node contains an array of data values",
			"option1"	: "Rolled linked list",
			"option2"	: "Unrolled linked list",
			"option3"	: "Linear linked list",
			"option4"	: "Directed linked list",
			"answer"	: 2
		},
		{
			"question"	: "A ________ is a linked list augmented with layers of pointers for quickly jumping over large numbers of elements, and then descending to the next layer",
			"option1"	: "Jump list",
			"option2"	: "Delete list",
			"option3"	: "Roll list",
			"option4"	: "Skip list",
			"answer"	: 4
		},
		{
			"question"	: "Random access lists can be implemented as__________ data structures",
			"option1"	: "Presistent",
			"option2"	: "Permanent",
			"option3"	: "Non-persistent",
			"option4"	: "Temporary",
			"answer"	: 1
		},
		{
			"question"	: "A __________ node may simplify certain list operations, by ensuring that the next and/or previous nodes exist for every element, and that even empty lists have at least one node",
			"option1"	: "Link",
			"option2"	: "Head",
			"option3"	: "Tail",
			"option4"	: "Sentinel",
			"answer"	: 4
		},
		{
			"question"	: "________ store several elements in each list node, increasing cache performance while decreasing memory overhead for references",
			"option1"	: "Rolled linked list",
			"option2"	: "Unrolled linked list",
			"option3"	: "Linear linked list",
			"option4"	: "Directed linked list",
			"answer"	: 2
		},
		{
			"question"	: "On adding a new node to q at the end,we make",
			"option1"	: "q-next=0",
			"option2"	: "q->next=0",
			"option3"	: "q->next=NULL",
			"option4"	: "Nothing",
			"answer"	: 3
		},
		{
			"question"	: "While Initializing Head Node in double linked list",
			"option1"	: "head->next=NULL",
			"option2"	: "Both A and C",
			"option3"	: "head->prev=NULL",
			"option4"	: "None",
			"answer"	: 2
		},
		{
			"question"	: "Linked lists can store______ type of data",
			"option1"	: "int",
			"option2"	: "char",
			"option3"	: "All",
			"option4"	: "string",
			"answer"	: 3
		},
		{
			"question"	: "In a Linked list the address of right adjacent node is held by",
			"option1"	: "*next",
			"option2"	: "*prev",
			"option3"	: "Both",
			"option4"	: "None",
			"answer"	: 1
		},
		{
			"question"	: "In a Linked list the address of left adjacent node is held by",
			"option1"	: "*next",
			"option2"	: "*prev",
			"option3"	: "Both",
			"option4"	: "None",
			"answer"	: 2
		},
		{
			"question"	: "The Number of Nodes to which a node in a Single-Linked list can be connected is",
			"option1"	: "4",
			"option2"	: "3",
			"option3"	: "2",
			"option4"	: "1",
			"answer"	: 3
		},
		{
			"question"	: "The Number of Nodes to which a node in a Double-Linked list can be connected is",
			"option1"	: "4",
			"option2"	: "3",
			"option3"	: "1",
			"option4"	: "2",
			"answer"	: 4
		}
	],
	[
		{
			"question"	: "How many nodes do a full binary tree with ‘N’ leaves contain? ",
			"option1"	: "2N nodes ",
			"option2"	: "N nodes ",
			"option3"	: "2N-1 nodes",
			"option4"	: "N-1 nodes",
			"answer"	: 3
		},
		{
			"question"	: "How many nodes does a complete binary tree of level 5 have?",
			"option1"	: "16",
			"option2"	: "31",
			"option3"	: "32",
			"option4"	: "15",
			"answer"	: 2
		},
		{
			"question"	: "There are four trees named A, B, C and D having 8, 15, 13, 14 nodes in them respectively. Which of them could have formed a full binary tree?",
			"option1"	: "A",
			"option2"	: "B",
			"option3"	: "C",
			"option4"	: "D",
			"answer"	: 2
		},
		{
			"question"	: "Of the following tree structure, which is efficient, considering space and time complexities?",
			"option1"	: "Incomplete Binary Tree",
			"option2"	: "Complete Binary Tree",
			"option3"	: "Full Binary Tree",
			"option4"	: "Binary Search Tree",
			"answer"	: 2
		},
		{
			"question"	: "Four statements about B-trees are below. three of them are correct. Which one is INCORRECT?",
			"option1"	: "All B-trees are also search trees",
			"option2"	: "The word B-tree stands for balanced tree",
			"option3"	: "The word B-tree also stands for binary tree",
			"option4"	: "All leaves of a B-tree must be on the same level",
			"answer"	: 3
		},
		{
			"question"	: "For any B-tree of height H (H>1), after inserting a new key, is it possible for a key, K, which was located in a leaf-node to move up to the root in this regard which of the following is correct?",
			"option1"	: "Can’t be defined without data",
			"option2"	: "Never",
			"option3"	: "Yes, only if H=2",
			"option4"	: "Yes",
			"answer"	: 4
		},
		{
			"question"	: "T is a search tree of order M, its size is N, and its height is K. The computation time needed to INSERT/DELETE a data item on T is",
			"option1"	: "O( 1 )",
			"option2"	: "O( M )",
			"option3"	: "O( Log K )",
			"option4"	: "O( K )",
			"answer"	: 4
		},
		{
			"question"	: "Which of the following statements is INCORRECT when the differences/similarities between binary search trees and heaps?",
			"option1"	: "Both binary search trees and heaps are binary trees",
			"option2"	: "Both binary search trees and heaps require ascending order between sibling nodes",
			"option3"	: "With heaps the smallest value is stored at the root, while with binary trees the smallest value is on the leftmost leaf",
			"option4"	: "In heaps no gaps are allowed apart from the right side of the leaves' level, but in binary search trees gaps are allowed",
			"answer"	: 2
		},
		{
			"question"	: "The time complexity of binary search in best, worst cases for an array of size N is",
			"option1"	: "N, N2",
			"option2"	: "1, Log N",
			"option3"	: "Log N, N2",
			"option4"	: "1, N log N",
			"answer"	: 2
		},
		{
			"question"	: "How many children do an external node of a binary tree of order N contains?",
			"option1"	: "N exactly",
			"option2"	: "N-1 exactly",
			"option3"	: "One exactly",
			"option4"	: "0 exactly",
			"answer"	: 4
		},
		{
			"question"	: "The in-order traversal of some binary tree produced the sequence HFIEJGZ, and the post-order traversal of the same tree produced the sequence HIFJZGE. What will be the total number of nodes in the left sub tree of the given tree?",
			"option1"	: "1",
			"option2"	: "2",
			"option3"	: "3",
			"option4"	: "4",
			"answer"	: 3
		},
		{
			"question"	: "Which of the following statements is true related to a B-tree?",
			"option1"	: "All entries of a node are greater than or equal to the entries in the node's children",
			"option2"	: "All leaves are at the different depths",
			"option3"	: "All the leaf nodes appear at same level",
			"option4"	: "All non-leaf nodes have the exact same number of children",
			"answer"	: 3
		},
		{
			"question"	: "What is the time taken by the binary search algorithm to search a key ‘k’ in a sorted array of ‘n’ elements?",
			"option1"	: "O(log2 n)",
			"option2"	: "O(n)",
			"option3"	: "(n log2 n)",
			"option4"	: "O(n2)",
			"answer"	: 1
		},
		{
			"question"	: "The number of null branches for a binary tree with 19 nodes is",
			"option1"	: "21",
			"option2"	: "20",
			"option3"	: "22",
			"option4"	: "19",
			"answer"	: 2
		},
		{
			"question"	: "A B-tree of order n is also called",
			"option1"	: "(n–n) –1 tree",
			"option2"	: "n–(n–2) tree",
			"option3"	: "(n–1)–n tree",
			"option4"	: "n–(n–1) tree",
			"answer"	: 3
		},
		{
			"question"	: "The minimum number of keys contained in each non root node of a B-tree of order 11 are",
			"option1"	: "4",
			"option2"	: "5",
			"option3"	: "3",
			"option4"	: "2",
			"answer"	: 2
		},
		{
			"question"	: "If a binary tree is threaded for an in order traversal order, a NULL right link of any node is replaced by the address of its",
			"option1"	: "Successor",
			"option2"	: "Predecessor",
			"option3"	: "Root",
			"option4"	: "Postdecessor",
			"answer"	: 1
		},
		{
			"question"	: "Worst case efficiency of binary search is",
			"option1"	: "log2 n + 1",
			"option2"	: "n",
			"option3"	: "2N",
			"option4"	: "2n",
			"answer"	: 1
		},
		{
			"question"	: "The time complexity of binary search in best, worst cases for an array of size 2 is",
			"option1"	: "2, 4",
			"option2"	: "2, 2",
			"option3"	: "Log 2, 6",
			"option4"	: "1, log 2",
			"answer"	: 4
		},
		{
			"question"	: "How many children do an external node of a binary tree of order N contains",
			"option1"	: "N at least ",
			"option2"	: "2 exactly",
			"option3"	: "More than two",
			"option4"	: "0",
			"answer"	: 4
		},
		{
			"question"	: "The Traversal of root first",
			"option1"	: "Post-order",
			"option2"	: "The order of increasing magnitude of their key",
			"option3"	: "Pre-order ",
			"option4"	: "The order of decreasing magnitude of their key N",
			"answer"	: 3
		},
		{
			"question"	: "For a binary tree the In-order traversal was found to be as HIGCEFD. Once the post-order traversal was conducted the output is IHGFEDC. What is the per-order for the given tree?",
			"option1"	: "CGDHEIF",
			"option2"	: "GHICDEF",
			"option3"	: "CGHIDEF",
			"option4"	: "CDEFGHI",
			"answer"	: 3
		},
		{
			"question"	: "What is the total number of nodes at every level (L) of a complete binary tree?",
			"option1"	: "2L",
			"option2"	: "2L–1",
			"option3"	: "3L–1",
			"option4"	: "4L",
			"answer"	: 1
		},
		{
			"question"	: "Value 18 is added to root as",
			"option1"	: "root=18",
			"option2"	: "root-value=18",
			"option3"	: "value->root=18",
			"option4"	: "root->value=18",
			"answer"	: 4
		},
		{
			"question"	: "The Traversal modes is/are: (i)Pre-order (ii)Post-order (iii)Level order (iv)In-order",
			"option1"	: "Only (i) and (ii)",
			"option2"	: "all",
			"option3"	: "Only (i),(ii) and (iii)",
			"option4"	: "Only (ii) and (iv)",
			"answer"	: 2
		},
		{
			"question"	: "The Traversal which Employs Left-Root-Right is",
			"option1"	: "In-order",
			"option2"	: "Pre-order",
			"option3"	: "Post-order",
			"option4"	: "Level-order",
			"answer"	: 1
		},
		{
			"question"	: "The Traversal which Employs Root-Left-Right is",
			"option1"	: "In-order",
			"option2"	: "Pre-order",
			"option3"	: "Post-order",
			"option4"	: "Level-order",
			"answer"	: 2
		},
		{
			"question"	: "The Traversal which Employs Left-Right-Root is",
			"option1"	: "In-order",
			"option2"	: "Pre-order",
			"option3"	: "Post-order",
			"option4"	: "Level-order",
			"answer"	: 3
		},
		{
			"question"	: "The Traversal which Traverses the Tree level by level is",
			"option1"	: "In-order",
			"option2"	: "Pre-order",
			"option3"	: "Post-order",
			"option4"	: "Level-order",
			"answer"	: 4
		},
		{
			"question"	: "The In-order Traversal Employs ",
			"option1"	: "Left-Root-Right",
			"option2"	: "Root-Left-Right",
			"option3"	: "Level by level",
			"option4"	: "Left-Right-Root",
			"answer"	: 1
		},
		{
			"question"	: "The Post-order Traversal Employs",
			"option1"	: "Left-Root-Right",
			"option2"	: "Root-Left-Right",
			"option3"	: "Level by level",
			"option4"	: "Left-Right-Root",
			"answer"	: 4
		},
		{
			"question"	: "The Level by Level Traversal Employs",
			"option1"	: "Left-Root-Right",
			"option2"	: "Root-Left-Right",
			"option3"	: "Level by level",
			"option4"	: "Left-Right-Root",
			"answer"	: 3
		},
		{
			"question"	: "The Pre-order Traversal Employs",
			"option1"	: "Left-Root-Right",
			"option2"	: "Root-Left-Right",
			"option3"	: "level by level",
			"option4"	: "Left-Right-Root",
			"answer"	: 2
		},
		{
			"question"	: "Tree is a _____________",
			"option1"	: "ADT",
			"option2"	: "BBT",
			"option3"	: "CDT",
			"option4"	: "DDT",
			"answer"	: 1
		},
		{
			"question"	: "Tree is a _________ structure",
			"option1"	: "Linear",
			"option2"	: "Non-linear",
			"option3"	: "Can be anything",
			"option4"	: "None",
			"answer"	: 2
		},
		{
			"question"	: "A BinaryTree exhibits",
			"option1"	: "No recursion",
			"option2"	: "Multiple recursion",
			"option3"	: "Mutual recursion",
			"option4"	: "None of the above",
			"answer"	: 3
		},
		{
			"question"	: "A general to be a binary tree, The parent must have ________ children",
			"option1"	: "Three",
			"option2"	: "Five",
			"option3"	: "Two",
			"option4"	: "Six",
			"answer"	: 3
		},
		{
			"question"	: "A ________ is a structure which may contain a value or condition of a tree",
			"option1"	: "Node",
			"option2"	: "Mode",
			"option3"	: "Data ",
			"option4"	: "Variable",
			"answer"	: 1
		},
		{
			"question"	: "________ is a self-balancing binary search tree",
			"option1"	: "PVL",
			"option2"	: "CVL",
			"option3"	: "DVL",
			"option4"	: "AVL",
			"answer"	: 4
		},
		{
			"question"	: "In an AVL tree, the heights of the two child subtrees of any node differ by at most",
			"option1"	: "2",
			"option2"	: "1",
			"option3"	: "3",
			"option4"	: "4",
			"answer"	: 2
		},
		{
			"question"	: "AVL trees are often compared with __________ because both support the same set of operations and take O(log n) time for the basic operations.",
			"option1"	: "blue-black trees",
			"option2"	: "white-black trees",
			"option3"	: "red-black trees",
			"option4"	: "violet-black trees",
			"answer"	: 3
		},
		{
			"question"	: "A ________’s height is at most 2log(n+1)",
			"option1"	: "Blue-black trees",
			"option2"	: "White-black trees",
			"option3"	: "Red-black trees",
			"option4"	: "Violet-black trees",
			"answer"	: 3
		},
		{
			"question"	: "Each internal node of a B-tree will contain a number of",
			"option1"	: "Nodes",
			"option2"	: "Keys",
			"option3"	: "Links",
			"option4"	: "Sub-trees",
			"answer"	: 2
		},
		{
			"question"	: "Binary tree was invented in",
			"option1"	: "1980",
			"option2"	: "1945",
			"option3"	: "1957",
			"option4"	: "1971",
			"answer"	: 4
		},
		{
			"question"	: "Which of the following is not a tree",
			"option1"	: "General tree",
			"option2"	: "Binary Tree",
			"option3"	: "Expression tree",
			"option4"	: "Normal tree",
			"answer"	: 4
		},
		{
			"question"	: "BST means",
			"option1"	: "Binary search tree",
			"option2"	: "Binary tree",
			"option3"	: "Binded sorted tree",
			"option4"	: "Bounded sorting tree",
			"answer"	: 1
		}
	],
	[
		{
			"question"	: "What would be the depth of tree whose level is 9 ",
			"option1"	: "10",
			"option2"	: "8",
			"option3"	: "9",
			"option4"	: "11",
			"answer"	: 3
		},
		{
			"question"	: "For the given 5 jobs with penalties 6, 3, 4, 8, 5 respectively, the static state space tree is generated, then if the first job is selected but not the second job for the first two jobs consideration, then the rank of such situational node is ______",
			"option1"	: "6",
			"option2"	: "3",
			"option3"	: "0",
			"option4"	: "9",
			"answer"	: 2
		},
		{
			"question"	: "The data structure used in the Hierarchical data model is",
			"option1"	: "Array",
			"option2"	: "Tree",
			"option3"	: "Graph",
			"option4"	: "Stack",
			"answer"	: 2
		},
		{
			"question"	: "The number of nodes a null tree can have is",
			"option1"	: "One",
			"option2"	: "Two",
			"option3"	: "Three",
			"option4"	: "Zero",
			"answer"	: 4
		},
		{
			"question"	: "In an arbitrary tree (not a search tree) of order M. Its size is N, and its height is K. The computation time needed to find a data item on T is",
			"option1"	: "O(K*K)",
			"option2"	: "O(M*M)",
			"option3"	: "O(N)",
			"option4"	: "O(K)",
			"answer"	: 3
		},
		{
			"question"	: "When we say the order of a tree is M, we mean",
			"option1"	: "Every non-leaf node must have M subtrees",
			"option2"	: "Every non-leaf node must have M keys",
			"option3"	: "Every non-leaf node can have at most M subtrees",
			"option4"	: "Every non-leaf node can have at most M keys",
			"answer"	: 3
		},
		{
			"question"	: "Consider a tree ‘t’ has two subtrees t1 and t2. Identify the tree where the subtree t1 has minimum height and the subtree t2 has maximum height",
			"option1"	: "Fibonacci",
			"option2"	: "B+",
			"option3"	: "Sparse",
			"option4"	: "Complete binary",
			"answer"	: 1
		},
		{
			"question"	: "Which of the following is not possible as a balance factor of any node of an AVL tree? I.-2  II.±1  III.0  IV.2 ",
			"option1"	: "Only (I) above",
			"option2"	: "Only (II) above",
			"option3"	: "Only (III) above",
			"option4"	: "Both (III) and (IV) above",
			"answer"	: 4
		},
		{
			"question"	: "Which of the following statement(s) is/are TRUE in view of a multi-way search tree? If a node has  I.4 sub trees it contains 3 keys.  II.5 keys, it has 7 sub trees.  III.6 sub trees, it contains 6 keys.  IV.10 keys if it contains 11 children",
			"option1"	: "Only (I) above",
			"option2"	: "Only (II) above",
			"option3"	: "Only (III) above",
			"option4"	: "Both (II) and (III) above",
			"answer"	: 4
		},
		{
			"question"	: "What would be the cost value for any answering node of a sub tree with root ‘r’ using branch-bound algorithm?",
			"option1"	: "Maximum",
			"option2"	: "Minimum",
			"option3"	: "Optimal",
			"option4"	: "Average",
			"answer"	: 2
		},
		{
			"question"	: "Name the node which has been generated but none of its children nodes have been generated in state space tree of backtracking method.",
			"option1"	: "Dead node",
			"option2"	: "Live node",
			"option3"	: "E-Node",
			"option4"	: "State Node",
			"answer"	: 2
		},
		{
			"question"	: "How many nodes are there in a full state space tree with n = 6?",
			"option1"	: "65",
			"option2"	: "64",
			"option3"	: "63",
			"option4"	: "32",
			"answer"	: 3
		},
		{
			"question"	: "In a General tree,the Root is first initialized to",
			"option1"	: "NULL",
			"option2"	: "0",
			"option3"	: "1",
			"option4"	: "-1",
			"answer"	: 1
		},
		{
			"question"	: "Value 18 is added to root as",
			"option1"	: "root=18",
			"option2"	: "root-value=18",
			"option3"	: "value->root=18",
			"option4"	: "root->value=18",
			"answer"	: 4
		},
		{
			"question"	: "The Traversal modes is/are: (i)Pre-order (ii)Post-order (iii)Level order (iv)In-order",
			"option1"	: "Only (i) and (ii)",
			"option2"	: "All",
			"option3"	: "Only (i),(ii) and (iii)",
			"option4"	: "Only (ii) and (iv)",
			"answer"	: 2
		},
		{
			"question"	: "The Traversal which Employs Left-Root-Right is",
			"option1"	: "In-order",
			"option2"	: "Pre-order",
			"option3"	: "Post-order",
			"option4"	: "Level-order",
			"answer"	: 1
		},
		{
			"question"	: "The Traversal which Employs Root-Left-Right is",
			"option1"	: "In-order",
			"option2"	: "Pre-order",
			"option3"	: "Post-order",
			"option4"	: "Level-order",
			"answer"	: 2
		},
		{
			"question"	: "The Traversal which Employs Left-Right-Root is",
			"option1"	: "In-order",
			"option2"	: "Pre-order",
			"option3"	: "Post-order",
			"option4"	: "Level-order",
			"answer"	: 3
		},
		{
			"question"	: "The Traversal which Traverses the Tree level by level is",
			"option1"	: "In-order",
			"option2"	: "Pre-order",
			"option3"	: "Post-order",
			"option4"	: "Level-order",
			"answer"	: 4
		},
		{
			"question"	: "The In-order Traversal Employs ",
			"option1"	: "Left-Root-Right",
			"option2"	: "Root-Left-Right",
			"option3"	: "Level by level",
			"option4"	: "Left-Right-Root",
			"answer"	: 1
		},{
			"question"	: "The Post-order Traversal Employs",
			"option1"	: "Left-Root-Right",
			"option2"	: "Root-Left-Right",
			"option3"	: "Level by level",
			"option4"	: "Left-Right-Root",
			"answer"	: 4
		},
		{
			"question"	: "The Level by Level Traversal Employs",
			"option1"	: "Left-Root-Right",
			"option2"	: "Root-Left-Right",
			"option3"	: "Level by level",
			"option4"	: "Left-Right-Root",
			"answer"	: 3
		},
		{
			"question"	: "The Pre-order Traversal Employs",
			"option1"	: "Left-Root-Right",
			"option2"	: "Root-Left-Right",
			"option3"	: "Level by level",
			"option4"	: "Left-Right-Root",
			"answer"	: 2
		},
		{
			"question"	: "The ________ node to which child node is connected is",
			"option1"	: "Connection",
			"option2"	: "Link",
			"option3"	: "Parent",
			"option4"	: "Bind",
			"answer"	: 3
		},
		{
			"question"	: "The Top Node in a tree is",
			"option1"	: "Root",
			"option2"	: "Child",
			"option3"	: "Parent",
			"option4"	: "Boot",
			"answer"	: 1
		},
		{
			"question"	: "The Converse Notion of a child is",
			"option1"	: "Root",
			"option2"	: "Child",
			"option3"	: "Parent",
			"option4"	: "Boot",
			"answer"	: 3
		},
		{
			"question"	: "Nodes with same parent are called?",
			"option1"	: "Root",
			"option2"	: "Level",
			"option3"	: "Siblings",
			"option4"	: "Leaves",
			"answer"	: 3
		},
		{
			"question"	: "A Node with no Children is",
			"option1"	: "Edge",
			"option2"	: "Path",
			"option3"	: "Parent",
			"option4"	: "Leaf",
			"answer"	: 4
		},
		{
			"question"	: "A node reachable by repeated proceeding from parent to child is",
			"option1"	: "Descendant",
			"option2"	: "Ancestor",
			"option3"	: "Leaf",
			"option4"	: "Edge",
			"answer"	: 1
		},
		{
			"question"	: "A node reachable by repeated proceeding from child to parent is",
			"option1"	: "Descendant",
			"option2"	: "Ancestor",
			"option3"	: "Leaf",
			"option4"	: "Edge",
			"answer"	: 2
		},{
			"question"	: "A node with at least one child is",
			"option1"	: "External node",
			"option2"	: "Single node",
			"option3"	: "Internal node",
			"option4"	: "None",
			"answer"	: 3
		},
		{
			"question"	: "Number of sub trees of a node is",
			"option1"	: "Path",
			"option2"	: "Edge",
			"option3"	: "Level",
			"option4"	: "Degree",
			"answer"	: 4
		},
		{
			"question"	: "Connection between one node to another is",
			"option1"	: "Edge",
			"option2"	: "Degree",
			"option3"	: "Path",
			"option4"	: "Level",
			"answer"	: 1
		},
		{
			"question"	: "A sequence of nodes and edges connecting a node with a descendant",
			"option1"	: "Edge",
			"option2"	: "Degree",
			"option3"	: "Path",
			"option4"	: "Level",
			"answer"	: 3
		},
		{
			"question"	: "The Number of edges on the longest downward path between the node and a leaf is",
			"option1"	: "Weight",
			"option2"	: "Value",
			"option3"	: "Level",
			"option4"	: "Height",
			"answer"	: 4
		},
		{
			"question"	: "A ______ is a set of n>0 disjoint trees",
			"option1"	: "Forest",
			"option2"	: "Sub trees",
			"option3"	: "Children",
			"option4"	: "Parents",
			"answer"	: 1
		},
		{
			"question"	: "A general tree can have _______ number of children",
			"option1"	: "Only one",
			"option2"	: "Only three",
			"option3"	: "Less than five",
			"option4"	: "Any",
			"answer"	: 4
		},
		{
			"question"	: "The Methods to implement a general tree is/are: (i)List of children (ii)Left children (iii)Right sibling",
			"option1"	: "(i) and (ii)",
			"option2"	: "(ii) and (iii)",
			"option3"	: "(i),(ii) and (iii)",
			"option4"	: "only (i)",
			"answer"	: 3
		},
		{
			"question"	: "The List of Children Representation uses",
			"option1"	: "Linked List",
			"option2"	: "Queues",
			"option3"	: "Array",
			"option4"	: "Both A and C",
			"answer"	: 4
		},
		{
			"question"	: "Application of trees are",
			"option1"	: "Representing Hierarchical data",
			"option2"	: "Representing sorted lists of data",
			"option3"	: "Routing algorithms",
			"option4"	: "All",
			"answer"	: 4
		},{
			"question"	: "Tree is a _____________",
			"option1"	: "ADT",
			"option2"	: "BBT",
			"option3"	: "CDT",
			"option4"	: "DDT",
			"answer"	: 1
		},
		{
			"question"	: "Tree is a _______ structure",
			"option1"	: "Linear",
			"option2"	: "Non-linear",
			"option3"	: "Can be anything",
			"option4"	: "None",
			"answer"	: 2
		},
		{
			"question"	: "Tree exhibits",
			"option1"	: "No recursion",
			"option2"	: "Multiple recursion",
			"option3"	: "Mutual recursion",
			"option4"	: "None of the above",
			"answer"	: 3
		},
		{
			"question"	: "A ________ is a structure which may contain a value or condition of a tree",
			"option1"	: "Node",
			"option2"	: "Mode",
			"option3"	: "Data",
			"option4"	: "Variable",
			"answer"	: 1
		},
		{
			"question"	: "A general to be a binary tree, The parent must have ________ children",
			"option1"	: "Three",
			"option2"	: "Five",
			"option3"	: "Two",
			"option4"	: "Six",
			"answer"	: 3
		},
		{
			"question"	: "The subtree corresponding to the root node is the",
			"option1"	: "Binary Tree",
			"option2"	: "Binary Search tree",
			"option3"	: "Both A and C",
			"option4"	: "Entire tree",
			"answer"	: 4
		},
		{
			"question"	: "The _______ of a node is the length of the path to its root.",
			"option1"	: "Weight",
			"option2"	: "Depth",
			"option3"	: "Height",
			"option4"	: "Path",
			"answer"	: 2
		},
		{
			"question"	: "Removing a whole section of a tree is",
			"option1"	: "Enumerating",
			"option2"	: "Grafting",
			"option3"	: "Pruning",
			"option4"	: "Manipulating",
			"answer"	: 3
		},
		{
			"question"	: "Adding a whole section to a tree is",
			"option1"	: "Enumerating",
			"option2"	: "Grafting",
			"option3"	: "Pruning",
			"option4"	: "Manipulating",
			"answer"	: 2
		},
		{
			"question"	: "Stepping through the items of a tree, by means of the connections between parents and children, is called",
			"option1"	: "Running the tree",
			"option2"	: "Traversing the tree",
			"option3"	: "Walking the tree",
			"option4"	: "Searching the tree",
			"answer"	: 3
		}
	],
	[
		{
			"question"	: "A node of a directed graph G having no out-degree and a positive in-degree is called",
			"option1"	: "Source node",
			"option2"	: "Sink Node",
			"option3"	: "Sibling Node",
			"option4"	: "Null Node",
			"answer"	: 1
		},
		{
			"question"	: "How do you determine the cost of a spanning tree?",
			"option1"	: "By the sum of the costs of the edges of the tree",
			"option2"	: "By the sum of the costs of the edges and vertices of the tree",
			"option3"	: "By the sum of the costs of the vertices of the tree",
			"option4"	: "By the sum of the costs of the edges of the graph",
			"answer"	: 1
		},
		{
			"question"	: "In a graph, a vertex with degree one is known as",
			"option1"	: "Pendant vertex",
			"option2"	: "Leaf",
			"option3"	: "Root",
			"option4"	: "End vertex",
			"answer"	: 1
		},
		{
			"question"	: "In tree construction, which is the suitable and efficient data structure",
			"option1"	: "Array",
			"option2"	: "Linked List",
			"option3"	: "Stack",
			"option4"	: "Queue",
			"answer"	: 2
		},
		{
			"question"	: "Let G be a graph with ‘n’ nodes and let ‘m’ be the chromatic number of the graph. Then the time taken by the backtracking algorithm to color it is",
			"option1"	: "O(nm)",
			"option2"	: "O(n+m)",
			"option3"	: "O(mn^m)",
			"option4"	: "O(nm^n).",
			"answer"	: 4
		},
		{
			"question"	: "The number of loop(s) of a node in a simple graph of ‘N’ nodes is",
			"option1"	: "One",
			"option2"	: "N",
			"option3"	: "Zero",
			"option4"	: "Exactly Two",
			"answer"	: 3
		},
		{
			"question"	: "A simple graph has no loops. Which of the following forms another property of a simple graph",
			"option1"	: "Contain un-weighted edges",
			"option2"	: "Undirected",
			"option3"	: "Have at least one vertex",
			"option4"	: "Have no multiple edges",
			"answer"	: 4
		},
		{
			"question"	: "Identify the correct problem for multistage graph from the list given below.",
			"option1"	: "Resource allocation problem",
			"option2"	: "Traveling salesperson problem",
			"option3"	: "Producer consumer problem",
			"option4"	: "Dining philosopher problem",
			"answer"	: 1
		},
		{
			"question"	: "Adjacency matrix of a digraph is",
			"option1"	: "Identity matrix",
			"option2"	: "Symmetric matrix",
			"option3"	: "Asymmetric matrix",
			"option4"	: "Sparse matrix",
			"answer"	: 3
		},
		{
			"question"	: "What is the major data structure used in the Network data model",
			"option1"	: "Stack",
			"option2"	: "Array",
			"option3"	: "Graph",
			"option4"	: "Tree",
			"answer"	: 3
		},
		{
			"question"	: "In the following weighted graph, the length of the minimum spanning tree is",
			"option1"	: "39",
			"option2"	: "depends on the starting vertex",
			"option3"	: "43",
			"option4"	: "52",
			"answer"	: 2
		},
		{
			"question"	: "If graph G has no edges then corresponding adjacency matrix is",
			"option1"	: "Unit matrix",
			"option2"	: "Zero matrix",
			"option3"	: "Matrix with all 1’s",
			"option4"	: "Upper diagonal matrix",
			"answer"	: 2
		},
		{
			"question"	: "Graph structure is available in",
			"option1"	: "Data Structures",
			"option2"	: "C",
			"option3"	: "C++",
			"option4"	: "Java",
			"answer"	: 1
		},
		{
			"question"	: "How many minimum number of spanning trees, one can have from a given connected graph with N nodes is having different weights for the edges",
			"option1"	: "N-1",
			"option2"	: "one",
			"option3"	: "1/(N+1) 2NCN",
			"option4"	: "N",
			"answer"	: 2
		},
		{
			"question"	: "At a given node of a simple graph, the number of loops are",
			"option1"	: "More than one",
			"option2"	: "Not more than one",
			"option3"	: "Zero",
			"option4"	: "Equal to the number of nodes of the graph",
			"answer"	: 3
		},
		{
			"question"	: "A …………… is an acyclic digraph, which has only one node with indegree 0, and other nodes have indegree 1",
			"option1"	: "Directed tree",
			"option2"	: "Undirected tree",
			"option3"	: "Dis-joint tree",
			"option4"	: "Direction oriented tree",
			"answer"	: 1
		},
		{
			"question"	: "In a graph if e=[u, v], Then u and v are called",
			"option1"	: "Endpoints of e",
			"option2"	: "Adjacent nodes",
			"option3"	: "Neighbours",
			"option4"	: "All of the above",
			"answer"	: 4
		},
		{
			"question"	: "A connected graph T without any cycles is called",
			"option1"	: "A tree graph",
			"option2"	: "Free tree",
			"option3"	: "A tree",
			"option4"	: "All of these",
			"answer"	: 4
		},
		{
			"question"	: "If every node u in G is adjacent to every other node v in G, A graph is said to be",
			"option1"	: "Isolated",
			"option2"	: "Complete",
			"option3"	: "Finite",
			"option4"	: "Strongly connected",
			"answer"	: 2
		},
		{
			"question"	: "The minimum number of edges in a connected cyclic graph on n vertices is",
			"option1"	: "n-1",
			"option2"	: "n-1",
			"option3"	: "n+1",
			"option4"	: "none of these",
			"answer"	: 2
		},
		{
			"question"	: "Sparse matrices have ",
			"option1"	: "Many zero entries",
			"option2"	: "Higher dimension",
			"option3"	: "Many non-zero entries",
			"option4"	: "None of the above",
			"answer"	: 1
		},
		{
			"question"	: "Which of the following expressions accesses the (I,j)th entry of an (mxn) matrix stored in column major form?",
			"option1"	: "Nx(i-j)+j",
			"option2"	: "Mx(n-j)+j",
			"option3"	: "Mx(j-1)+i",
			"option4"	: "nX(m-i)+j",
			"answer"	: 3
		},
		{
			"question"	: "The minimum number of colors needed to color a graph having n(>3) vertices and 2 edges is",
			"option1"	: "4",
			"option2"	: "3",
			"option3"	: "2",
			"option4"	: "1",
			"answer"	: 3
		},
		{
			"question"	: "Which of the following is useful in traversing a given graph by breadth first search",
			"option1"	: "Stack",
			"option2"	: "Set",
			"option3"	: "List",
			"option4"	: "Queue",
			"answer"	: 4
		},
		{
			"question"	: "The number of edges in a regular graph of degree d and vertices n is Maximum of n,d",
			"option1"	: "n+d",
			"option2"	: "nd",
			"option3"	: "nd/2",
			"option4"	: "N",
			"answer"	: 4
		},
		{
			"question"	: "Which of the following is not a type of Graph",
			"option1"	: "Adjacent graph",
			"option2"	: "Simple graph",
			"option3"	: "Weighted Graph",
			"option4"	: "Labeled Graph",
			"answer"	: 1
		}
	],
	[
		{
			"question"	: "What do you call the selected keys in the quick sort method?",
			"option1"	: "Outer key",
			"option2"	: "Inner Key",
			"option3"	: "Partition key",
			"option4"	: "Pivot key",
			"answer"	: 4
		},
		{
			"question"	: "For the bubble sort algorithm, what is the time complexity of the best/worst case",
			"option1"	: "best case: O(n) worst case: O(n*n)",
			"option2"	: "best case: O(n) worst case: O(n*log(n))",
			"option3"	: "best case: O(n*log(n)) worst case: O(n*log(n))",
			"option4"	: "best case: O(n*log(n)) worst case: O(n*n)",
			"answer"	: 1
		},
		{
			"question"	: "The Sorting method which is used for external sort is",
			"option1"	: "Bubble sort",
			"option2"	: "Quick sort",
			"option3"	: "Merge sort",
			"option4"	: "Radix sort",
			"answer"	: 3
		},
		{
			"question"	: "For the quick sort algorithm, what is the time complexity of the best/worst case",
			"option1"	: "best case: O(n) worst case: O(n*n)",
			"option2"	: "best case: O(n) fworst case: O(n*log(n))",
			"option3"	: "best case: O(n*log(n)) worst case: O(n*log(n))",
			"option4"	: "best case: O(n*log(n)) worst case: O(n*n)",
			"answer"	: 4
		},
		{
			"question"	: "Which of following algorithm scans the list by swapping the entries whenever pair of adjacent keys are out of desired order",
			"option1"	: "Insertion sort",
			"option2"	: "Quick sort",
			"option3"	: "Shell sort",
			"option4"	: "Bubble sort",
			"answer"	: 4
		},
		{
			"question"	: "What is the algorithm, which scans the list by swapping the entries whenever pair of adjacent keys is out of desired order?",
			"option1"	: "Insertion sort ",
			"option2"	: "Quick sort ",
			"option3"	: "Shell sort ",
			"option4"	: "Bubble sort ",
			"answer"	: 4
		},
		{
			"question"	: "Identify the name of the sorting in which time is not proportional to n^2",
			"option1"	: "Selection sort",
			"option2"	: "Bubble sort",
			"option3"	: "Qucik sort",
			"option4"	: "Merge sort",
			"answer"	: 4
		},
		{
			"question"	: "Which of the following versions of merge sort algorithm does uses space efficiently",
			"option1"	: "Contiguous version",
			"option2"	: "Array version",
			"option3"	: "Structure version",
			"option4"	: "Linked version",
			"answer"	: 3
		},
		{
			"question"	: "This sort finds location ‘pos’ of smallest elements in a(i), …. , a(n) and then interchange a(pos) with a(i) for i = 1, …., n – 1",
			"option1"	: "Selection sort",
			"option2"	: "Quick sort",
			"option3"	: "Heap sort",
			"option4"	: "Bubble sort",
			"answer"	: 1
		},
		{
			"question"	: "What do we call the selected keys in quick sort?",
			"option1"	: "Recombine key",
			"option2"	: "Inner key",
			"option3"	: "Outer key",
			"option4"	: "Pivot key",
			"answer"	: 1
		},
		{
			"question"	: "This algorithm scans the list by swapping the entries whenever pair of adjacent keys are out of desired order",
			"option1"	: "Insertion sort",
			"option2"	: "Bubble sort",
			"option3"	: "Shell sort",
			"option4"	: "Quick sort",
			"answer"	: 2
		},
		{
			"question"	: "Sorting is not possible by using which of the following methods",
			"option1"	: "Insertion",
			"option2"	: "Selection",
			"option3"	: "Exchange",
			"option4"	: "Deletion",
			"answer"	: 4
		},
		{
			"question"	: "The element at the root of heap is",
			"option1"	: "Largest",
			"option2"	: "Smallest",
			"option3"	: "Depending on type of heap it may be smallest or largest",
			"option4"	: "Fixed",
			"answer"	: 3
		},
		{
			"question"	: "This algorithm scans the list by swapping the entries whenever pair of adjacent keys are out of desired order",
			"option1"	: "Insertion sort",
			"option2"	: "Quick sort",
			"option3"	: "Shell sort",
			"option4"	: "Bubble sort",
			"answer"	: 4
		},
		{
			"question"	: "The complexity of Bubble sort algorithm is ",
			"option1"	: "O(n)",
			"option2"	: "O(log n)",
			"option3"	: "O(n2)",
			"option4"	: "O(n log n)",
			"answer"	: 3
		},
		{
			"question"	: "The complexity of merge sort algorithm is",
			"option1"	: "O(n)",
			"option2"	: "O(log n)",
			"option3"	: "O(n2)",
			"option4"	: "O(n log n)",
			"answer"	: 4
		},
		{
			"question"	: "Which of the following sorting algorithm is of divide-and-conquer type?",
			"option1"	: "Bubble sort",
			"option2"	: "Insertion sort",
			"option3"	: "Quick sort",
			"option4"	: "All of the above",
			"answer"	: 3
		},
		{
			"question"	: "Which of the sorting procedure is the slowest",
			"option1"	: "Quick sort",
			"option2"	: "Heap sort",
			"option3"	: "Shell Sort",
			"option4"	: "Bubble Sort",
			"answer"	: 4
		},
		{
			"question"	: "Which of the sorting method is stable",
			"option1"	: "Straighten Insertion Sort",
			"option2"	: "Binary insertion Sort",
			"option3"	: "Shell Sort",
			"option4"	: "Heap Sort",
			"answer"	: 1
		},
		{
			"question"	: "Which of the following best describes sorting",
			"option1"	: "Accessing and processing Each Record Exactly Once",
			"option2"	: "Finding the location Of the record with the given key",
			"option3"	: "Arranging the data in some given order",
			"option4"	: "Adding a new record to the data structure",
			"answer"	: 3
		},
		{
			"question"	: "A sort which compares adjacent elements is a list and switches where necessary is",
			"option1"	: "Insertion sort",
			"option2"	: "Heap Sort",
			"option3"	: "Quick Sort",
			"option4"	: "Bubble Sort",
			"answer"	: 4
		},
		{
			"question"	: "A sort which iteratively passes through a list to exchange the first element with ane element less than it and then repeats with a new first element is",
			"option1"	: "Insertion sort",
			"option2"	: "Selection sort",
			"option3"	: "Heap sort",
			"option4"	: "Quick sort",
			"answer"	: 2
		},
		{
			"question"	: "The data for which you are searching is called ",
			"option1"	: "Search argument",
			"option2"	: "Sort argument",
			"option3"	: "Detection argument",
			"option4"	: "Binary argument",
			"answer"	: 1
		},
		{
			"question"	: "The numbers of swapping needed to sort the numbers 8,22,7,9,31,19,5,13 in ascending orger using bubble sort is",
			"option1"	: "11",
			"option2"	: "12",
			"option3"	: "13",
			"option4"	: "14",
			"answer"	: 4
		},
		{
			"question"	: "Sorting is Useful For",
			"option1"	: "Report generation",
			"option2"	: "Responding to queries easily",
			"option3"	: "Making searching easier and efficient",
			"option4"	: "All of the above",
			"answer"	: 4
		},
		{
			"question"	: "Breadth first search ",
			"option1"	: "Scans each incident node along with its children",
			"option2"	: "Scans all incident edges before moving to other node",
			"option3"	: "Is same as backtracking",
			"option4"	: "Scans all the nodes in random order",
			"answer"	: 2
		},
		{
			"question"	: "For the ease of searching in a linked list, the linked list be created in",
			"option1"	: "Descending order",
			"option2"	: "Ascending order",
			"option3"	: "Without underflow condition",
			"option4"	: "With underflow condition",
			"answer"	: 4
		},
		{
			"question"	: "Which of the following in breadth first search uses data structures as an auxiliary structure to hold nodes for future processing",
			"option1"	: "Queue",
			"option2"	: "Linked list",
			"option3"	: "Graph",
			"option4"	: "Stack",
			"answer"	: 1
		},
		{
			"question"	: "Which of the following search method will always find a goal node nearest to the root of the tree",
			"option1"	: "Depth first search",
			"option2"	: "Binary search",
			"option3"	: "Breadth first search",
			"option4"	: "Heuristic search",
			"answer"	: 3
		},
		{
			"question"	: "The time complexity of binary search in best, worst cases for the array of size N is",
			"option1"	: "N, N^2",
			"option2"	: "N, N",
			"option3"	: "1, logN",
			"option4"	: "1, NlogN",
			"answer"	: 1
		},
		{
			"question"	: "Find the correct sequence for the Big Oh values for all n > 2",
			"option1"	: "O(1) < O( n) < O( log n) < O(n log n) < O(n2) < O(n3) < O(2n)",
			"option2"	: "O(1) < O(log n) < O(n) < O(n log n) < O(n2) < O(2n) < O(n3)",
			"option3"	: "O(1) < O(log n) < O(n) < O(n log n) < O(n2) < O(n3) < O(2n)",
			"option4"	: "O(1) < O(n) < O(log n) < O(n log n) < O(n2) < O(2n) < O(n3)",
			"answer"	: 3
		},
		{
			"question"	: "Worst case efficiency of which search is O(n)",
			"option1"	: "Sequential search",
			"option2"	: "Binary search",
			"option3"	: "Indexed search",
			"option4"	: "Hashing",
			"answer"	: 1
		},
		{
			"question"	: "Breadth first search",
			"option1"	: "Scans all incident edges before moving to other vertex",
			"option2"	: "Scans adjacent unvisited vertex as soon as possible",
			"option3"	: "Is same as backtracking",
			"option4"	: "Scans for cycle in graph, that no such cycle exists",
			"answer"	: 1
		},
		{
			"question"	: "Which of the following searching methods requires that all keys must reside in internal memory",
			"option1"	: "Binary search",
			"option2"	: "Sequential search",
			"option3"	: "Hashing",
			"option4"	: "Depth first search",
			"answer"	: 1
		},
		{
			"question"	: "Consider searching for a given value in a large, sorted array. Under which of the following conditions is sequential search slower than binary search?",
			"option1"	: "Always",
			"option2"	: "Never",
			"option3"	: "When the value being searched for is the first element in the array",
			"option4"	: "When the value being searched for is the second element in the array",
			"answer"	: 1
		},
		{
			"question"	: "Breadth first search uses __________ as an auxiliary structure to hold nodes for future processing",
			"option1"	: "Stack",
			"option2"	: "Linked list",
			"option3"	: "Queue",
			"option4"	: "Graph",
			"answer"	: 3
		},
		{
			"question"	: "Which of the following is not the required condition for binary search algorithm",
			"option1"	: "The list must be sorted",
			"option2"	: "There should be the direct access to the middle element in any sublist",
			"option3"	: "There must be mechanism to delete and/or insert elements in list",
			"option4"	: "none of above",
			"answer"	: 3
		},
		{
			"question"	: "Which of the following is not a limitation of binary search algorithm",
			"option1"	: "Must use a sorted array",
			"option2"	: "Requirement of sorted array is expensive when a lot of insertion and deletions are needed",
			"option3"	: "There must be a mechanism to access middle element directly",
			"option4"	: "Binary search algorithm is not efficient when the data elements are more than 1000.",
			"answer"	: 1
		},
		{
			"question"	: "Binary search algorithm can not be applied to",
			"option1"	: "Sorted linked list",
			"option2"	: "Sorted binary trees",
			"option3"	: "Sorted linear array",
			"option4"	: "Pointer array",
			"answer"	: 1
		},
		{
			"question"	: "Finding the location of the element with a given value is:",
			"option1"	: "Traversal",
			"option2"	: "Search",
			"option3"	: "Sort",
			"option4"	: "None of these",
			"answer"	: 2
		},
		{
			"question"	: "The time complexity of linear search algorithm over an array of n elements is",
			"option1"	: "O(log2n)",
			"option2"	: "O(n)",
			"option3"	: "O(nlog2n)",
			"option4"	: "O(n^2)",
			"answer"	: 1
		},
		{
			"question"	: "In which of the following algorithms which does not have the worst case running time of O(n^2)",
			"option1"	: "Insertion sort",
			"option2"	: "Quick sort",
			"option3"	: "Merge Sort",
			"option4"	: "Bubble Sort",
			"answer"	: 2
		},
		{
			"question"	: "Using Standard algorithm what is the time required to determine the number n is prime?",
			"option1"	: "Linear time",
			"option2"	: "Logarithmic time ",
			"option3"	: "Constant time",
			"option4"	: "Quadratic Time",
			"answer"	: 1
		},
		{
			"question"	: "A search begins with the element located in the middle of the array ",
			"option1"	: "Serial",
			"option2"	: "Random",
			"option3"	: "Parallel",
			"option4"	: "Binary",
			"answer"	: 4
		}
	],
	[
		{
			"question"	: "The worst case time complexity of the nondeterministic dynamic knapsack algorithm is",
			"option1"	: "O(n log n)",
			"option2"	: "O(log n)",
			"option3"	: "O(n2)",
			"option4"	: "O(n)",
			"answer"	: 4
		},
		{
			"question"	: "Recursive algorithms are based on",
			"option1"	: "Divide and conquer approach",
			"option2"	: "Top-down approach",
			"option3"	: "Bottom-up approach ",
			"option4"	: "Hierarchical approach",
			"answer"	: 2
		},
		{
			"question"	: "The time complexity of the normal quick sort, randomized quick sort algorithms in the worst case is",
			"option1"	: "O(n2), O(n log n)",
			"option2"	: "O(n2), O(n2)",
			"option3"	: "O(n log n), O(n2)",
			"option4"	: "O(n log n), O(n log n)",
			"answer"	: 2
		},
		{
			"question"	: "Let there be an array of length ‘N’, and the selection sort algorithm is used to sort it, how many times a swap function is called to complete the execution?",
			"option1"	: "N log N times",
			"option2"	: "log N times",
			"option3"	: "N2 times",
			"option4"	: "N-1 times",
			"answer"	: 4
		},
		{
			"question"	: "In analysis of algorithm, approximate relationship between the size of the job and the amount of work required to do is expressed by using",
			"option1"	: "Central tendency",
			"option2"	: "Differential equation",
			"option3"	: "Order of execution",
			"option4"	: "Order of magnitude",
			"answer"	: 4
		},
		{
			"question"	: "For analyzing an algorithm, which is better computing time?",
			"option1"	: "O (100 Log N)",
			"option2"	: "O (N)",
			"option3"	: "O (2N)",
			"option4"	: "O (N log N)",
			"answer"	: 1
		},
		{
			"question"	: "To implement the Round Robin algorithm, which of the following data structure is used?",
			"option1"	: "Stack",
			"option2"	: "Linear Queue",
			"option3"	: "Circular Queue",
			"option4"	: "Priority Queue",
			"answer"	: 3
		},
		{
			"question"	: "Consider the usual algorithm for determining whether a sequence of parentheses is balanced. What is the maximum number of parentheses that will appear on the stack AT ANY ONE TIME when the algorithm analyzes: (()(())(()))",
			"option1"	: "1",
			"option2"	: "2",
			"option3"	: "3",
			"option4"	: "4",
			"answer"	: 3
		},
		{
			"question"	: "The Knapsack problem where the objective function is to minimize the profit is ",
			"option1"	: "Greedy",
			"option2"	: "Dynamic 0 / 1",
			"option3"	: "Back tracking",
			"option4"	: "Branch & Bound 0/1 ",
			"answer"	: 4
		},
		{
			"question"	: "The graph coloring algorithm’s time can be bounded by ",
			"option1"	: "O(mn^m) ",
			"option2"	: "O(n^m)",
			"option3"	: "O(nm^n)",
			"option4"	: "O(m^n.2^n)",
			"answer"	: 3
		},
		{
			"question"	: "What is the type of the algorithm used in solving the 8 Queens problem?",
			"option1"	: "Greedy",
			"option2"	: "Dynamic",
			"option3"	: "Branch and bound",
			"option4"	: "Backtracking",
			"answer"	: 4
		},
		{
			"question"	: "The time complexity of the shortest path algorithm can be bounded by",
			"option1"	: "O(n^2)",
			"option2"	: "O(n^4)",
			"option3"	: "O(n^3)",
			"option4"	: "O(n)",
			"answer"	: 3
		},
		{
			"question"	: "Read the following statements carefully and pick the correct option: I.The worst time complexity of the Floyd’s algorithm is O(n3). II.The worst time complexity of the Warshall’s algorithm is O(n3)",
			"option1"	: "(I) is false but (II) is true",
			"option2"	: "(I) is true but (II) is false",
			"option3"	: "Both (I) and (II) are true",
			"option4"	: "(I) is true and (II) is not true always",
			"answer"	: 3
		},
		{
			"question"	: "For the bubble sort algorithm, what is the time complexity of the best/worst case? (assume that the computation stops as soon as no more swaps in one pass)",
			"option1"	: "best case: O(n) worst case: O(n*n)",
			"option2"	: "best case: O(n) worst case: O(n*log(n))",
			"option3"	: "best case: O(n*log(n)) worst case: O(n*log(n))",
			"option4"	: "best case: O(n*log(n)) worst case: O(n*n)",
			"answer"	: 1
		},
		{
			"question"	: "For the quick sort algorithm, what is the time complexity of the best/worst case?",
			"option1"	: "best case: O(n) worst case: O(n*n)",
			"option2"	: "best case: O(n) worst case: O(n*log(n))",
			"option3"	: "best case: O(n*log(n)) worst case: O(n*log(n))",
			"option4"	: "best case: O(n*log(n)) worst case: O(n*n)",
			"answer"	: 4
		},
		{
			"question"	: "When we organize our data as an ordered list, what is the time complexity of inserting/deleting a data item to/from the list?",
			"option1"	: "O(length_of_list*length_of_list)",
			"option2"	: "O(length_of_list)",
			"option3"	: "O(log(length_of_list * length_of_list))",
			"option4"	: "O(1)",
			"answer"	: 2
		},
		{
			"question"	: "T is a search tree of order M, its size is N, and its height is K. The computation time needed to INSERT/DELETE a data item on T is",
			"option1"	: "O( 1 )",
			"option2"	: "O( M )",
			"option3"	: "O( Log K )",
			"option4"	: "O( K )",
			"answer"	: 4
		},
		{
			"question"	: "Find the odd one out from the following categories of algorithms",
			"option1"	: "TVSP",
			"option2"	: "Bin-Packing",
			"option3"	: "OBST",
			"option4"	: "N-Queens",
			"answer"	: 2
		},
		{
			"question"	: "The time complexity of binary search in best, worst cases for an array of size N is",
			"option1"	: "N, N^2",
			"option2"	: "1, Log N",
			"option3"	: "Log N, N^2",
			"option4"	: "1, N log N",
			"answer"	: 2
		},
		{
			"question"	: "Which of following algorithm scans the list by swapping the entries whenever pair of adjacent keys are out of desired order?",
			"option1"	: "Insertion sort",
			"option2"	: "Quick sort",
			"option3"	: "Shell sort",
			"option4"	: "Bubble sort",
			"answer"	: 4
		},
		{
			"question"	: "Which of the following belongs to the algorithm paradigm?",
			"option1"	: "Minimum & Maximum problem",
			"option2"	: "Knapsack problem",
			"option3"	: "Selection problem",
			"option4"	: "Merge sort",
			"answer"	: 2
		},
		{
			"question"	: "What is the algorithm, which scans the list by swapping the entries whenever pair of adjacent keys is out of desired order?",
			"option1"	: "Insertion sort",
			"option2"	: "Quick sort",
			"option3"	: "Shell sort",
			"option4"	: "Bubble sort",
			"answer"	: 4
		},
		{
			"question"	: "Pick the correct statement(s) from the following set of statements: (I). In the Kruskal’s algorithm, for the construction of minimal spanning tree for a graph, the selected edges always form a forest (II).In Prim’s algorithm, for the construction of minimal spanning tree for a graph, the selected edges always form an orchard (III).DFS, BFS algorithms always make use of a queue, and stack respectively",
			"option1"	: "Only (I) above",
			"option2"	: "Only (II) above",
			"option3"	: "Only (III) above",
			"option4"	: "Both (II) and (III) above.",
			"answer"	: 1
		},
		{
			"question"	: "What is the time taken by the binary search algorithm to search a key ‘k’ in a sorted array of ‘n’ elements?",
			"option1"	: "O(log2 n)",
			"option2"	: "(n log2 n)",
			"option3"	: "O(n2)",
			"option4"	: "O(n)",
			"answer"	: 1
		},
		{
			"question"	: "For the smart bubble sort algorithm, what is the time complexity of the best and worst case?",
			"option1"	: "best case: O(n) worst case: O(n*log n)",
			"option2"	: "best case: O(n*log n) worst case: O(n*log n)",
			"option3"	: "best case: O(n) worst case: O(n2)",
			"option4"	: "best case: O(n*log n) worst case: O(n2)",
			"answer"	: 3
		},
		{
			"question"	: "Find the odd one out from the following categories of algorithms",
			"option1"	: "Bin-packing",
			"option2"	: "OBST",
			"option3"	: "N-Queens",
			"option4"	: "15-Puzzle",
			"answer"	: 1
		},
		{
			"question"	: "Minimum number of queue(s) needed to implement the priority queue is(are)",
			"option1"	: "4",
			"option2"	: "3",
			"option3"	: "2",
			"option4"	: "1",
			"answer"	: 3
		},
		{
			"question"	: "In Knapsack problem, the best strategy to get the optimal solution, where Pi, Wi is the Profit, Weight associated with each of the Xith object respectively is to",
			"option1"	: "Arrange the values Pi/Wi in ascending order",
			"option2"	: "Arrange the values Pi/Xi in ascending order",
			"option3"	: "Arrange the values Pi/Wi in descending order",
			"option4"	: "Arrange the values Pi/Xi in descending order",
			"answer"	: 4
		},
		{
			"question"	: "Greedy job scheduling with deadlines algorithms’ complexity is defined as ",
			"option1"	: "O(N)",
			"option2"	: "Ω( n log n)",
			"option3"	: "O( n log n)",
			"option4"	: "Ω(N^2).",
			"answer"	: 1
		},
		{
			"question"	: "In analysis of algorithm, approximate relationship between the size of the job and the amount of work required to do it is expressed by using",
			"option1"	: "Order of magnitude or Big - O",
			"option2"	: "Central tendency",
			"option3"	: "Differential equation",
			"option4"	: "Polynomial equation",
			"answer"	: 1
		},
		{
			"question"	: "Which of the following is the correct big-O expression for 1 + 2 + 3 + ... + n",
			"option1"	: "O(log n)",
			"option2"	: "O(n)",
			"option3"	: "O(n log n)",
			"option4"	: "O(n²)",
			"answer"	: 4
		},
		{
			"question"	: "Worst case efficiency of binary search is",
			"option1"	: "log2 n + 1",
			"option2"	: "n",
			"option3"	: "N^2",
			"option4"	: "2^n",
			"answer"	: 1
		},
		{
			"question"	: "Which of the following formulas in Omega notation best represent the expression n²+35n+6?",
			"option1"	: "Ω(n³)",
			"option2"	: "Ω(n²)",
			"option3"	: "Ω(n)",
			"option4"	: "Ω(35)",
			"answer"	: 1
		},
		{
			"question"	: "What term is used to describe an O(n) algorithm",
			"option1"	: "Constant",
			"option2"	: "Linear",
			"option3"	: "Non Polynomial Deterministic",
			"option4"	: "Logarithmic",
			"answer"	: 2
		},
		{
			"question"	: "Which of the following are essential statement types for describing algorithms?",
			"option1"	: "Sequence ",
			"option2"	: "Selection",
			"option3"	: "Repetition",
			"option4"	: "All the above",
			"answer"	: 4
		},
		{
			"question"	: "When we say an algorithm has a time complexity of O (n), what does it mean?",
			"option1"	: "The algorithm has ‘n’ nested loops",
			"option2"	: "The computation time taken by the algorithm is proportional to n",
			"option3"	: "The algorithm is ‘n’ times slower than a standard algorithm",
			"option4"	: "There are ‘n’ number of statements in the algorithm",
			"answer"	: 2
		},
		{
			"question"	: "Can we read a data item at any location of a list within a constant time (i.e. O(1))?",
			"option1"	: "Yes",
			"option2"	: "Yes, only if the list is implemented by pointers (i.e. linked-list)",
			"option3"	: "Yes, only if the list is implemented by an array",
			"option4"	: "No, we need O(n) computation steps no matter what kind of implementation is used",
			"answer"	: 3
		},
		{
			"question"	: "Sequential search has a time complexity of O(n), and binary search has a time complexity ofO(log(n)). What difference will it make when the size n is 1000",
			"option1"	: "You would not notice much difference because computers run very fast anyway",
			"option2"	: "As n is 1000, binary search is twice as fast as sequential search",
			"option3"	: "As n is 1000, binary search is 100 times as fast as sequential search",
			"option4"	: "As n is 1000, binary search is 10 times as fast as sequential search",
			"answer"	: 3
		},
		{
			"question"	: "Read the following statements carefully, and choose the correct answer (I) The Ω notation is Anti Symmetric    (II)The big Oh notation is Semi Equivalence.",
			"option1"	: "(I) is FALSE but (II) is TRUE",
			"option2"	: "Both (I), (II) are TRUE",
			"option3"	: "(I) is TRUE but (II) is FALSE",
			"option4"	: "Both (I), (II) are FALSE",
			"answer"	: 2
		},
		{
			"question"	: "Find the odd one out",
			"option1"	: "Bin-Packing Problem",
			"option2"	: "Knap Sack Problem",
			"option3"	: "OBST Problem",
			"option4"	: "Sum of Sub Sets Problem",
			"answer"	: 1
		},
		{
			"question"	: "This algorithm scans the list by swapping the entries whenever pair of adjacent keys are out of desired order.",
			"option1"	: "Insertion sort ",
			"option2"	: "Quick sort",
			"option3"	: "Shell sort",
			"option4"	: "Bubble sort",
			"answer"	: 4
		},
		{
			"question"	: "Read the following statements carefully, and choose the correct answer(I) For the Backtracking algorithms stack data structure is used  (II) For the Branch-and-bound algorithms queue data structure is used.",
			"option1"	: "(I) is FALSE but (II) is TRUE",
			"option2"	: "(I) and (II) both are FALSE",
			"option3"	: "(I) is TRUE but (II) is FALSE",
			"option4"	: "(I) and (II) both are TRUE",
			"answer"	: 4
		},
		{
			"question"	: "The time taken by nondeterministic sorting algorithm is ",
			"option1"	: "O(1)",
			"option2"	: "O(log n)",
			"option3"	: "O(n^2)",
			"option4"	: "O(n)",
			"answer"	: 4
		},
		{
			"question"	: "If h is any hashing function and is used to hash n keys in to a table of size m, where n<=m, the expected number of collisions involving a particular key x is",
			"option1"	: "Less than 1 ",
			"option2"	: "Less than n",
			"option3"	: "Less than m",
			"option4"	: "Less than n/2",
			"answer"	: 1
		},
		{
			"question"	: "A technique for direct search is",
			"option1"	: "Linear Search",
			"option2"	: "Binary search",
			"option3"	: "Hashing",
			"option4"	: "Tree search",
			"answer"	: 3
		},
		{
			"question"	: "The searching technique that takes O (1) time to find a data is",
			"option1"	: "Linear Search",
			"option2"	: "Binary Search",
			"option3"	: "Tree Search",
			"option4"	: "Hashing",
			"answer"	: 4
		},
		{
			"question"	: "The goal of hashing is to produce a search that takes",
			"option1"	: "O(1) time",
			"option2"	: "O(n2 )time",
			"option3"	: "O(log n ) time",
			"option4"	: "O(n log n ) time",
			"answer"	: 1
		},
		{
			"question"	: "Key value pairs is usually seen in",
			"option1"	: "Heaps",
			"option2"	: "Hash tables",
			"option3"	: "Both a and b",
			"option4"	: "skip List",
			"answer"	: 2
		},
		{
			"question"	: "What is the best definition of a collision in a hash table?",
			"option1"	: "Two entries with different data have the exact same key.",
			"option2"	: "Two entries with different keys have the same exact hash value.",
			"option3"	: "Two entries with the exact same key have different hash values.",
			"option4"	: "Two entries are identical except for their keys",
			"answer"	: 4
		},
		{
			"question"	: "Which of the following scenarios leads to linear running time for a random search hit in a linear-probing hash table?",
			"option1"	: "All keys hash to different indices",
			"option2"	: "All keys hash to same index",
			"option3"	: "All keys hash to an even-numbered index",
			"option4"	: "All keys hash to different even-numbered indices",
			"answer"	: 2
		},
		{
			"question"	: "The method of access which uses key transformation is known as",
			"option1"	: "Direct",
			"option2"	: "Hash",
			"option3"	: "Random",
			"option4"	: "Sequential",
			"answer"	: 2
		}
	]
];